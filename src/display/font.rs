//! 8x8 Bitmap Font System
//!
//! Public domain font data from: https://github.com/dhepper/font8x8

use super::PixelBuffer;

/// Font glyph dimensions
pub const GLYPH_WIDTH: u32 = 8;
pub const GLYPH_HEIGHT: u32 = 8;

/// Draw a single 8x8 glyph bitmap at the given position
#[inline]
pub fn draw_glyph(buffer: &mut PixelBuffer, x: i32, y: i32, glyph: &[u8; 8], r: u8, g: u8, b: u8) {
    draw_glyph_scaled(buffer, x, y, glyph, r, g, b, 1);
}

/// Draw a scaled glyph (nearest-neighbor scaling)
#[inline]
pub fn draw_glyph_scaled(
    buffer: &mut PixelBuffer,
    x: i32,
    y: i32,
    glyph: &[u8; 8],
    r: u8,
    g: u8,
    b: u8,
    scale: u32,
) {
    for (row, &bits) in glyph.iter().enumerate() {
        for col in 0..8 {
            if bits & (1 << col) != 0 {
                // Draw a scaleÃ—scale block for each pixel
                for sy in 0..scale as i32 {
                    for sx in 0..scale as i32 {
                        buffer.set_pixel(
                            x + col * scale as i32 + sx,
                            y + row as i32 * scale as i32 + sy,
                            r,
                            g,
                            b,
                        );
                    }
                }
            }
        }
    }
}

/// Draw a single character at the given position
pub fn draw_char(buffer: &mut PixelBuffer, x: i32, y: i32, ch: char, r: u8, g: u8, b: u8) {
    draw_char_scaled(buffer, x, y, ch, r, g, b, 1);
}

/// Draw a scaled character
pub fn draw_char_scaled(
    buffer: &mut PixelBuffer,
    x: i32,
    y: i32,
    ch: char,
    r: u8,
    g: u8,
    b: u8,
    scale: u32,
) {
    if let Some(glyph) = get_glyph(ch) {
        draw_glyph_scaled(buffer, x, y, glyph, r, g, b, scale);
    }
}

/// Draw a text string at the given position
pub fn draw_text(buffer: &mut PixelBuffer, x: i32, y: i32, text: &str, r: u8, g: u8, b: u8) {
    draw_text_scaled(buffer, x, y, text, r, g, b, 1);
}

/// Draw a scaled text string
pub fn draw_text_scaled(
    buffer: &mut PixelBuffer,
    x: i32,
    y: i32,
    text: &str,
    r: u8,
    g: u8,
    b: u8,
    scale: u32,
) {
    let char_width = GLYPH_WIDTH * scale;
    let mut cursor_x = x;
    for ch in text.chars() {
        draw_char_scaled(buffer, cursor_x, y, ch, r, g, b, scale);
        cursor_x += char_width as i32;
    }
}

/// Calculate the pixel width of a text string
#[inline]
pub fn text_width(text: &str) -> u32 {
    text_width_scaled(text, 1)
}

/// Calculate the pixel width of a scaled text string
#[inline]
pub fn text_width_scaled(text: &str, scale: u32) -> u32 {
    text.chars().count() as u32 * GLYPH_WIDTH * scale
}

/// Draw text centered horizontally on the screen
pub fn draw_text_centered(buffer: &mut PixelBuffer, y: i32, text: &str, r: u8, g: u8, b: u8) {
    draw_text_centered_scaled(buffer, y, text, r, g, b, 1);
}

/// Draw scaled text centered horizontally
pub fn draw_text_centered_scaled(
    buffer: &mut PixelBuffer,
    y: i32,
    text: &str,
    r: u8,
    g: u8,
    b: u8,
    scale: u32,
) {
    let width = text_width_scaled(text, scale) as i32;
    let x = (buffer.width() as i32 - width) / 2;
    draw_text_scaled(buffer, x, y, text, r, g, b, scale);
}

/// Draw text with a solid background box
pub fn draw_text_boxed(
    buffer: &mut PixelBuffer,
    y: i32,
    text: &str,
    fg: (u8, u8, u8),
    bg: (u8, u8, u8),
    scale: u32,
    padding: u32,
) {
    let text_w = text_width_scaled(text, scale);
    let text_h = GLYPH_HEIGHT * scale;
    let box_w = text_w + padding * 2;
    let box_h = text_h + padding * 2;
    let box_x = (buffer.width() - box_w) as i32 / 2;
    let box_y = y - padding as i32;

    // Draw background
    buffer.fill_rect(box_x, box_y, box_w, box_h, bg.0, bg.1, bg.2);

    // Draw text
    draw_text_centered_scaled(buffer, y, text, fg.0, fg.1, fg.2, scale);
}

/// Look up the glyph bitmap for a character
pub fn get_glyph(ch: char) -> Option<&'static [u8; 8]> {
    match ch {
        ' ' => Some(&SPACE),
        '0'..='9' => Some(&DIGITS[ch as usize - '0' as usize]),
        'A'..='Z' => Some(&UPPERCASE[ch as usize - 'A' as usize]),
        'a'..='z' => Some(&LOWERCASE[ch as usize - 'a' as usize]),
        ':' => Some(&PUNCT_COLON),
        '*' => Some(&PUNCT_ASTERISK),
        '-' => Some(&PUNCT_DASH),
        '.' => Some(&PUNCT_DOT),
        '!' => Some(&PUNCT_EXCLAIM),
        '?' => Some(&PUNCT_QUESTION),
        '/' => Some(&PUNCT_SLASH),
        _ => None,
    }
}

// ============================================================================
// Font Data (Public Domain - font8x8 by Daniel Hepper)
// ============================================================================

const SPACE: [u8; 8] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

// Punctuation glyphs (from font8x8)
const PUNCT_COLON: [u8; 8] = [0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00]; // :
const PUNCT_ASTERISK: [u8; 8] = [0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00]; // *
const PUNCT_DASH: [u8; 8] = [0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00]; // -
const PUNCT_DOT: [u8; 8] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00]; // .
const PUNCT_EXCLAIM: [u8; 8] = [0x0C, 0x1E, 0x1E, 0x0C, 0x0C, 0x00, 0x0C, 0x00]; // !
const PUNCT_QUESTION: [u8; 8] = [0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00]; // ?
const PUNCT_SLASH: [u8; 8] = [0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00]; // /

const DIGITS: [[u8; 8]; 10] = [
    [0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00], // 0
    [0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00], // 1
    [0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00], // 2
    [0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00], // 3
    [0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00], // 4
    [0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00], // 5
    [0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00], // 6
    [0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00], // 7
    [0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00], // 8
    [0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00], // 9
];

const UPPERCASE: [[u8; 8]; 26] = [
    [0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00], // A
    [0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00], // B
    [0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00], // C
    [0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00], // D
    [0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00], // E
    [0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00], // F
    [0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00], // G
    [0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00], // H
    [0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00], // I
    [0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00], // J
    [0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00], // K
    [0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00], // L
    [0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00], // M
    [0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00], // N
    [0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00], // O
    [0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00], // P
    [0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00], // Q
    [0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00], // R
    [0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00], // S
    [0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00], // T
    [0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00], // U
    [0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00], // V
    [0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00], // W
    [0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00], // X
    [0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00], // Y
    [0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00], // Z
];

const LOWERCASE: [[u8; 8]; 26] = [
    [0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00], // a
    [0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00], // b
    [0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00], // c
    [0x38, 0x30, 0x30, 0x3E, 0x33, 0x33, 0x6E, 0x00], // d
    [0x00, 0x00, 0x1E, 0x33, 0x3F, 0x03, 0x1E, 0x00], // e
    [0x1C, 0x36, 0x06, 0x0F, 0x06, 0x06, 0x0F, 0x00], // f
    [0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F], // g
    [0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00], // h
    [0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00], // i
    [0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E], // j
    [0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00], // k
    [0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00], // l
    [0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00], // m
    [0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00], // n
    [0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00], // o
    [0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F], // p
    [0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78], // q
    [0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00], // r
    [0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00], // s
    [0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00], // t
    [0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00], // u
    [0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00], // v
    [0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00], // w
    [0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00], // x
    [0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F], // y
    [0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00], // z
];
